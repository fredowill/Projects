import java.util.Arrays;
import java.util.Comparator;

import components.map.Map;
import components.map.Map.Pair;
import components.map.Map1L;
import components.set.Set;
import components.set.Set1L;
import components.simplereader.SimpleReader;
import components.simplereader.SimpleReader1L;
import components.simplewriter.SimpleWriter;
import components.simplewriter.SimpleWriter1L;

/**
 * This program creates a glossary of words organized in an unordered list with
 * hyperlinks to the definitions. If any of the words are in the definitions,
 * there will be a hyperlink that links back to the definition of that word.
 *
 * @author Ephratah Meskel
 *
 */
public final class GlossaryIndex {

    /**
     * Private constructor so this utility class cannot be instantiated.
     */
    private GlossaryIndex() {
    }

    /**
     *
     * Gets a map of words and definition from the text file given in the data
     * by the user.
     *
     * @param input
     *            a text file from the data folder
     * @param wordsDef
     *            the words -> it's definition
     * @updates wordsDef
     * @requires <pre> for the last set of words and definitions in the text
     *           file, there should be an empty line proceeding the last line
     *           </pre>
     * @ensures <pre> wordsDef = a set of words(k) and definitions(v) with all
     *          of the sets within the text file </pre>
     */
    public static void getWordsAndDefinitions(SimpleReader input,
            Map<String, String> wordsDef) {

        String def = "";
        String nextLine;
        String word;
        String empty = "";
        boolean flag = true;
        while (!input.atEOS()) {
            word = input.nextLine();
            nextLine = input.nextLine();
            def = "";
            while (!nextLine.equals(empty) && flag) {

                def = def + nextLine;
                if (!input.atEOS()) {
                    nextLine = input.nextLine();
                } else {
                    flag = false;
                }

            }
            wordsDef.add(word, def);

        }

    }

    /**
     * Outputs the "opening" tags in the generated HTML file. These are the
     * expected elements generated by this method:
     *
     * <html> <head> <title>Glossary</title> </head> <body>
     * <h2>Glossary</h2>
     * <hr>
     * <h3>Index</h3>
     * <ul>
     *
     * @param out
     *            the output stream
     * @updates out.content
     * @ensures out.content = #out.content * [the HTML "opening" tags]
     */
    private static void startingIndexHTML(SimpleWriter out) {
        out.println("<!DOCTYPE html>");
        out.println("<html lang=\'en\'>");
        out.println("<title>Glossary</title>");
        out.println("</head>");
        out.println("<body>");
        out.println("<h2>Glossary</h2>");
        out.println("<hr>");
        out.println("<h3>Index</h3>");
        out.println("<ul>");
    }

    /**
     * Outputs a list of all the keywords in the {@code Map} and prints them out
     * in an unordered list in html in alphabetical order with hyperlinks to its
     * definition. example of an iteration:
     *
     * @param map
     *            words -> definitions
     * @param out
     *            the output stream
     * @updates out.content
     * @ensures out.content = #out.content * [the HTML "body" tags and the
     *          unordered list with hyperlinks to those definitions]
     */
    private static void endingIndexHTML(Map<String, String> map,
            SimpleWriter out) {
        String[] tempArray = new String[map.size()];
        int i = 0;
        for (Map.Pair<String, String> tempPair : map) {
            String tempStr = tempPair.key();
            tempArray[i++] = tempStr;
        }
        Arrays.sort(tempArray, new Comparator<String>() {

            @Override
            public int compare(String o1, String o2) {
                return o1.compareTo(o2);
            }

        });
        for (String tempStr : tempArray) {
            out.print("<li><a href='");
            out.print(tempStr + ".html");
            out.print("'>");
            out.print(tempStr);
            out.print("</a></li>");
            out.println();
        }

        out.println("</ul>");
        out.println("</body>");
        out.println("</html>");
    }

    /**
     * Returns a string of the definition with hyperlinks to each word if there
     * are any in the definition.
     *
     * @param map
     *            words -> definitions
     * @param separatorSet
     *            A set of separator characters
     * @param currentDef
     *            the current definition being printed out to its word on the
     *            html file
     * @return a string of {@code String}
     * @ensures <pre> result = currentDef ||
     * currentDef * [hyperlink to keys in map] </pre>
     */
    private static String replaceKeywordWithLink(Map<String, String> map,
            Set<Character> separatorSet, String currentDef) {

        StringBuffer result = new StringBuffer();

        int position = 0;
        while (position < currentDef.length()) {
            String token = nextWordOrSeparator(currentDef, position,
                    separatorSet);
            if (map.hasKey(token)) {
                result.append("<a href='" + token + ".html'>" + token + "</a>");
            } else {
                result.append(token);
            }
            position += token.length();
        }
        return result.toString();

    }

    /**
     * Prints out a page with the word highlighted in red in the top right
     * corner and the definition, with keywords having hyperlinks linked back to
     * it's definition.
     *
     * @param map
     *            words -> definitions
     * @param pair
     *            the current pair of word and definition that are being printed
     *            to the file
     * @param separatorSet
     *            a set of separator characters
     * @param out
     *            the output stream
     *
     * @updates tempDef
     * @ensures <pre> result = currentDef ||
     * currentDef * [hyperlink to keys in map] </pre>
     */
    private static void defHTML(Map<String, String> map,
            Pair<String, String> pair, Set<Character> separatorSet,
            SimpleWriter out) {

        String tempWord = pair.key();
        String tempDef = pair.value();
        out.println("<!DOCTYPE html>");
        out.println("<html lang=\'en\'>");
        out.println("<head>");
        out.println("<title>" + tempWord + "</title>");
        out.println("<body>");
        out.println("<h2><b><i><font color='red'>");
        out.print(tempWord + "</font></i></b></h2>");

        tempDef = replaceKeywordWithLink(map, separatorSet, tempDef);

        out.println("<blockquote>" + tempDef + "</blockquote>");

        out.println("<hr/>");
        out.println("<p>Return to <a href=\"index.html\">index</a>.</p>");
        out.println("</body>");
        out.println("</html>");

    }

    /**
     * Generates the set of characters in the given {@code String} into the
     * given {@code Set}.
     *
     * @param str
     *            the given {@code String}
     * @param charSet
     *            the {@code Set} to be replaced
     * @replaces charSet
     * @ensures charSet = entries(str)
     */
    public static void generateElements(String str, Set<Character> charSet) {
        assert str != null : "Violation of: str is not null";
        assert charSet != null : "Violation of: charSet is not null";

        int size = str.length();
        for (int i = 0; i < size; i++) {
            char tempStr = str.charAt(i);
            if (!charSet.contains(tempStr)) {
                charSet.add(tempStr);
            }

        }
    }

    /**
     * Returns the first "word" (maximal length string of characters not in
     * {@code separators}) or "separator string" (maximal length string of
     * characters in {@code separators}) in the given {@code text} starting at
     * the given {@code position}.
     *
     * @param text
     *            the {@code String} from which to get the word or separator
     *            string
     * @param position
     *            the starting index
     * @param separators
     *            the {@code Set} of separator characters
     * @return the first word or separator string found in {@code text} starting
     *         at index {@code position}
     * @requires 0 <= position < |text|
     * @ensures <pre>
     * nextWordOrSeparator =
     *   text[position, position + |nextWordOrSeparator|)  and
     * if entries(text[position, position + 1)) intersection separators = {}
     * then
     *   entries(nextWordOrSeparator) intersection separators = {}  and
     *   (position + |nextWordOrSeparator| = |text|  or
     *    entries(text[position, position + |nextWordOrSeparator| + 1))
     *      intersection separators /= {})
     * else
     *   entries(nextWordOrSeparator) is subset of separators  and
     *   (position + |nextWordOrSeparator| = |text|  or
     *    entries(text[position, position + |nextWordOrSeparator| + 1))
     *      is not subset of separators)
     * </pre>
     */
    public static String nextWordOrSeparator(String text, int position,
            Set<Character> separators) {
        assert text != null : "Violation of: text is not null";
        assert separators != null : "Violation of: separators is not null";
        assert 0 <= position : "Violation of: 0 <= position";
        assert position < text.length() : "Violation of: position < |text|";

        StringBuilder result = new StringBuilder();
        boolean hasSep = true;
        char startChar = text.charAt(position);

        if (separators.contains(startChar)) {
            for (int i = position; i < text.length() && hasSep; i++) {
                if (separators.contains(text.charAt(i))) {
                    char temp = text.charAt(i);
                    result.append(temp);
                } else {
                    hasSep = false;
                }
            }
        } else {
            hasSep = false;
            for (int i = position; i < text.length() && !hasSep; i++) {
                if (!separators.contains(text.charAt(i))) {
                    char temp = text.charAt(i);
                    result.append(temp);
                } else {
                    hasSep = true;
                }
            }

        }
        return result.toString();
    }

    /**
     * Main method.
     *
     * @param args
     *            the command line arguments
     */
    public static void main(String[] args) {

        SimpleWriter out = new SimpleWriter1L();
        SimpleReader in = new SimpleReader1L();
        out.println(
                "Enter a valid file location for the file you would like to use:");
        String fileInLocation = in.nextLine();
        out.println(
                "Enter a valid folder for where you would like the output to be:");
        String fileOutLocation = in.nextLine();
        final String separatorStr = " \t,?;:!/.";
        Set<Character> separatorSet = new Set1L<>();
        generateElements(separatorStr, separatorSet);

        String index = "index.html";

        SimpleReader textInput = new SimpleReader1L(fileInLocation);
        SimpleWriter textOutput = new SimpleWriter1L(
                fileOutLocation + "/" + index);

        Map<String, String> wordsDef = new Map1L<String, String>();
        getWordsAndDefinitions(textInput, wordsDef);

        startingIndexHTML(textOutput);
        endingIndexHTML(wordsDef, textOutput);

        for (Pair<String, String> pair : wordsDef) {
            String tempWord = pair.key();
            SimpleWriter tempFileOut = new SimpleWriter1L(
                    fileOutLocation + "/" + tempWord + ".html");
            defHTML(wordsDef, pair, separatorSet, tempFileOut);
        }

        in.close();
        out.close();
    }
}
